"""
AWS CDK Stack for the KratosNOVA project.
This stack defines the entire cloud infrastructure, including IAM roles,
DynamoDB tables, S3 buckets, Lambda functions, and API Gateway.
"""
from aws_cdk import (
    Stack,
    RemovalPolicy,
    Duration,
    aws_lambda as _lambda,
    aws_apigateway as apigw,
    aws_iam as iam,
    aws_dynamodb as dynamodb,
    aws_s3 as s3,
    aws_cloudwatch as cloudwatch,
    aws_events as events,
    aws_events_targets as targets,
)
from constructs import Construct


class KratosNovaStack(Stack):
    """
    Defines the main infrastructure stack for the KratosNOVA application.
    """
    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)

        # =================================================================
        # ==================== S3 Bucket Definition ======================
        # =================================================================

        # S3 bucket for storing generated artifacts (images)
        artifacts_bucket = s3.Bucket(
            self, "ArtifactsBucket",
            # bucket_name is auto-generated by CDK for uniqueness, which is a best practice.
            removal_policy=RemovalPolicy.DESTROY,
            auto_delete_objects=True,
            block_public_access=s3.BlockPublicAccess.BLOCK_ALL,
            encryption=s3.BucketEncryption.S3_MANAGED,
            enforce_ssl=True,
        )

        # =================================================================
        # ==================== IAM Role Definition ========================
        # =================================================================

        # Create a single IAM Role for all Lambda functions in the project
        lambda_role = iam.Role(
            self, "KratosNovaLambdaRole",
            assumed_by=iam.ServicePrincipal("lambda.amazonaws.com"),
            description="Unified role for all KratosNOVA project Lambda functions"
        )

        # Grant the Lambda role read/write permissions to the S3 bucket
        artifacts_bucket.grant_read_write(lambda_role)

        # Add Bedrock Permissions (Invoke our specific models)
        lambda_role.add_to_policy(iam.PolicyStatement(
            actions=["bedrock:InvokeModel"],
            resources=[
                f"arn:aws:bedrock:{self.region}::foundation-model/anthropic.claude-3-sonnet-20240229-v1:0",
                f"arn:aws:bedrock:{self.region}::foundation-model/anthropic.claude-3-haiku-20240307-v1:0",
                f"arn:aws:bedrock:{self.region}::foundation-model/stability.stable-diffusion-xl-v1"
            ],
            effect=iam.Effect.ALLOW
        ))

        # Add basic Lambda permissions for logging
        lambda_role.add_managed_policy(
            iam.ManagedPolicy.from_aws_managed_policy_name(
                "service-role/AWSLambdaBasicExecutionRole"
            )
        )

        # =================================================================
        # ==================== DynamoDB Table Definitions =================
        # =================================================================

        # 1. Contracts Table
        contracts_table = dynamodb.Table(
            self, "ContractsTable",
            partition_key=dynamodb.Attribute(
                name="contract_id", type=dynamodb.AttributeType.STRING
            ),
            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,
            removal_policy=RemovalPolicy.DESTROY
        )

        # 2. Submissions Table
        submissions_table = dynamodb.Table(
            self, "SubmissionsTable",
            partition_key=dynamodb.Attribute(
                name="submission_id", type=dynamodb.AttributeType.STRING
            ),
            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,
            removal_policy=RemovalPolicy.DESTROY
        )

        # 3. Agents Table
        agents_table = dynamodb.Table(
            self, "AgentsTable",
            partition_key=dynamodb.Attribute(
                name="agent_id", type=dynamodb.AttributeType.STRING
            ),
            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,
            removal_policy=RemovalPolicy.DESTROY
        )
        
        # Grant the Lambda role read/write permissions to all our tables
        contracts_table.grant_read_write_data(lambda_role)
        submissions_table.grant_read_write_data(lambda_role)
        agents_table.grant_read_write_data(lambda_role)

        # =================================================================
        # ===================== Lambda Layer Definition ===================
        # =================================================================

        common_layer = _lambda.LayerVersion(
            self, "CommonUtilsLayer",
            code=_lambda.Code.from_asset("lambda_layers/common_utils"),
            compatible_runtimes=[_lambda.Runtime.PYTHON_3_11],
            description="A common layer for shared Python libraries like requests."
        )

        # =================================================================

        # =================================================================
        # ================== Lambda & API Gateway Definition ================
        # =================================================================

        # --- Helper function to create Lambda functions ---
        def create_lambda_function(self, name: str, handler_folder: str, role: iam.Role, environment: dict, layers: list): # <-- Додали layers
            return _lambda.Function(
                self, name,
                runtime=_lambda.Runtime.PYTHON_3_11,
                handler="app.handler",
                code=_lambda.Code.from_asset(f"src/{handler_folder}"),
                role=role,
                environment=environment,
                layers=layers # <-- Додали цей рядок
            )

        # --- Helper function for AI-intensive Lambda functions ---
        def create_ai_agent_function(self, name: str, handler_folder: str, role: iam.Role, environment: dict, layers: list):
            return _lambda.Function(
                self, name,
                runtime=_lambda.Runtime.PYTHON_3_11,
                handler="app.handler",
                code=_lambda.Code.from_asset(f"src/{handler_folder}"),
                role=role,
                environment=environment,
                layers=layers,
                timeout=Duration.seconds(30) # <-- ВАЖЛИВА ЗМІНА!
            )

        # --- Environment variables for all functions ---
        lambda_environment = {
            "CONTRACTS_TABLE_NAME": contracts_table.table_name,
            "SUBMISSIONS_TABLE_NAME": submissions_table.table_name,
            "AGENTS_TABLE_NAME": agents_table.table_name,
            "ARTIFACTS_BUCKET_NAME": artifacts_bucket.bucket_name
        }

        # --- Create all Lambda functions ---
        goals_handler = create_lambda_function(self, "GoalsHandler", "goals_manager", lambda_role, lambda_environment, layers=[common_layer])
        contracts_handler = create_lambda_function(self, "ContractsHandler", "contracts_manager", lambda_role, lambda_environment, layers=[common_layer])
        submissions_handler = create_lambda_function(self, "SubmissionsHandler", "submissions_manager", lambda_role, lambda_environment, layers=[common_layer])
        results_handler = create_lambda_function(self, "ResultsHandler", "results_manager", lambda_role, lambda_environment, layers=[common_layer])
        agents_handler = create_lambda_function(self, "AgentsHandler", "agents_manager", lambda_role, lambda_environment, layers=[common_layer])
        uploads_handler = create_lambda_function(self, "UploadsHandler", "uploads_manager", lambda_role, lambda_environment, layers=[common_layer])

        # --- Define the API Gateway ---
        api = apigw.RestApi(
            self, "KratosNovaApi",
            rest_api_name="KratosNOVA Service",
            description="API for the KratosNOVA agent economy.",
            default_cors_preflight_options=apigw.CorsOptions(
                allow_origins=apigw.Cors.ALL_ORIGINS,
                allow_methods=apigw.Cors.ALL_METHODS
            )
        )

        # --- Define API Resources and Methods ---

        # POST /goals
        goals_resource = api.root.add_resource("goals")
        goals_resource.add_method(
            "POST",
            apigw.LambdaIntegration(goals_handler)
        )

        # GET /goals/{goal_id}
        goal_id_resource = goals_resource.add_resource("{goal_id}")
        goal_id_resource.add_method(
            "GET",
            apigw.LambdaIntegration(results_handler)
        )

        # GET /contracts
        contracts_resource = api.root.add_resource("contracts")
        contracts_resource.add_method(
            "GET",
            apigw.LambdaIntegration(contracts_handler)
        )

        # GET /contracts/{contract_id}
        contract_id_resource = contracts_resource.add_resource("{contract_id}")
        contract_id_resource.add_method(
            "GET",
            apigw.LambdaIntegration(contracts_handler)
        )

        # POST /contracts/{contract_id}/submissions
        submissions_resource = contract_id_resource.add_resource("submissions")
        submissions_resource.add_method(
            "POST",
            apigw.LambdaIntegration(submissions_handler)
        )

        # POST /agents
        agents_resource = api.root.add_resource("agents")
        agents_resource.add_method(
            "POST",
            apigw.LambdaIntegration(agents_handler)
        )

        # --- Handle /submissions resource ---
        # Note: We create a top-level /submissions resource for utility endpoints like getting an upload URL.
        submissions_root_resource = api.root.add_resource("submissions")

        # POST /submissions/upload-url
        upload_url_resource = submissions_root_resource.add_resource("upload-url")
        upload_url_resource.add_method(
            "POST",
            apigw.LambdaIntegration(uploads_handler)
        )

        # --- Create Freelancer Agent Functions ---
        artist_agent_handler = create_ai_agent_function( # <-- ЗМІНЕНО
            self, 
            "ArtistAgentHandler", 
            "agent_artist", 
            lambda_role, 
            lambda_environment, 
            layers=[common_layer]
        )

        copywriter_agent_handler = create_lambda_function(
            self,
            "CopywriterAgentHandler",
            "agent_copywriter",
            lambda_role,
            lambda_environment,
            layers=[common_layer]
        )

        # =================================================================
        # =================== CloudWatch Dashboard Definition ==============
        # =================================================================

        dashboard = cloudwatch.Dashboard(
            self, "KratosNovaDashboard",
            dashboard_name="KratosNOVA-Monitoring"
        )

        # --- Create a title for the Lambda metrics section ---
        dashboard.add_widgets(cloudwatch.TextWidget(
            markdown="# KratosNOVA API Lambda Metrics",
            width=24,
            height=1
        ))

        # --- Create widgets for each Lambda function ---
        lambda_functions = [
            {"name": "GoalsHandler", "function": goals_handler},
            {"name": "ContractsHandler", "function": contracts_handler},
            {"name": "SubmissionsHandler", "function": submissions_handler},
            {"name": "ResultsHandler", "function": results_handler},
        ]

        for item in lambda_functions:
            function_name = item["name"]
            lambda_function = item["function"]

            # Invocations Widget
            invocations_widget = cloudwatch.GraphWidget(
                title=f"{function_name} - Invocations",
                left=[lambda_function.metric_invocations(
                    period=Duration.minutes(5),
                    statistic="Sum"
                )],
                width=12,
                height=6
            )

            # Errors Widget
            errors_widget = cloudwatch.GraphWidget(
                title=f"{function_name} - Errors",
                left=[lambda_function.metric_errors(
                    period=Duration.minutes(5),
                    statistic="Sum"
                )],
                width=12,
                height=6
            )
            
            dashboard.add_widgets(invocations_widget, errors_widget)

        # =================================================================
        # =================== Agent Trigger Definitions ===================
        # =================================================================

        # Create an EventBridge rule to trigger the Artist Agent every 5 minutes
        artist_rule = events.Rule(
            self, "ArtistAgentTriggerRule",
            schedule=events.Schedule.rate(Duration.minutes(5))
        )

        # Set the Lambda function as the target for the rule
        artist_rule.add_target(targets.LambdaFunction(artist_agent_handler))
        # Add the Copywriter agent as another target to the same rule
        artist_rule.add_target(targets.LambdaFunction(copywriter_agent_handler))